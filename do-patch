#!/usr/bin/env bash

now=`date +%Y%m%d%H%M%S`

function usage()
{
    cmd=$(basename $0)
    echo "Usage: $cmd [-R] [-n] [-l] <patch-file>"
    echo "             -R               : remove patch"
    echo "             -n               : just print the patch"
    echo "             -l               : consider the last patch"
}

# TODO: check if new file present in the patch are not present in the working copy
opts=""
dryrun=0
last=0
while getopts hRnl flag
do
    case $flag in
        l)
            last=1
            ;;
        n)
            dryrun=1
            ;;
        R)
            opts="-R"
            ;;
        h)
            usage
            exit
            ;;
        ?)
            usage
            exit
            ;;
    esac
done
shift $(( OPTIND - 1 ))  # shift to the last flag or argument

if [  $# -eq 0 ]
then
    usage
    exit
fi

patchfile="$1"
if [ ! -f "$patchfile" ]; then
    npatch=$(ls -1 $PATCHES_DIR|grep $1|wc -l)
    if [ $npatch -ne 1 ]; then
        if [ $last -eq 1 ]; then
            # check if patches with the same name
            npatch=$(ls -1 $PATCHES_DIR|grep $1| sed 's/-[0-9][0-9][0-9][0-9][0-9][0-9]-[0-9][0-9][0-9][0-9][0-9][0-9]-/-/'|sort|uniq|wc -l)
            if [ $npatch -ne 1 ]; then
                echo "Cannot find uniq patch file with: $1"
                ls -1 $PATCHES_DIR|grep --color $1
                exit
            else
                patch=$(ls -1 $PATCHES_DIR|grep $1|tail -1)
            fi
        else
            echo "Cannot find uniq patch file with: $1"
            ls -1 $PATCHES_DIR|grep --color $1
            exit
        fi
    else
        patch=$(ls -1 $PATCHES_DIR|grep $1)
    fi

    patchfile="$PATCHES_DIR/$patch"
fi



cmd="patch -p0 $opts < $patchfile"
echo "> $cmd"
if [ $dryrun -eq 0 ]; then
    eval "$cmd"
else
    cat $patchfile
fi
