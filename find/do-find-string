#!/usr/bin/env bash



cmd=`basename $0`

function usage() {
    echo "Usage: $cmd [-h] [-a] [-i] [-b] [-p] [-c ] [-l|L] [-s "substitute-string"][-e <exclude-patt>] [-r <root>] [-n <depth>] [-f <file-pattern>] [-C n] [-w] [-t|T|R <topic>] <string>"
    echo "where:"
    echo "       -h                          : print this help"
    echo "       -i                          : ignore case"
    echo "       -b                          : include binary files"
    echo "       -c                          : just count occurences"
    echo "       -p                          : just print the paths"
    echo "       -r <root>                   : start from root folder"
    echo "       -n <depth>                  : max depth to search into"
    echo "       -f <file-pattern>           : filename pattern to use"
    echo "       -e <exclude-patt>           : exclude pattern"
    echo "       -a                          : use ack-grep"
    echo "       -s \"substitute-string\"    : substitute <string> with substitute-string"
    echo "       -C n                        : context like A2 B1 C3..."
    echo "       -l                          : list available topics"
    echo "       -L                          : print last topic, same as -T -"
    echo "       -t <topic|->                : append the result to [-=last] topic file"
    echo "       -T <topic|->                : print [-=last] topic file"
    echo "       -R <topic|->                : reset [-=last] topic file"
    echo "       -w                          : find whole word"
    echo "       -v                          : verbose"
    echo "       -q                          : quiet"
}

function print_topic() {
  topic="$1"
  topic_file=$(echo "${HOME}/.do-find-string/${topic}.txt")
  [ ! -f "${topic_file}" ] && return
  root=""
  cat "$topic_file" | while read -r line
  do
    [ "${line:0:6}" == "# PWD=" ] && root="${line:6}" && continue
    [ "${line:0:1}" == "#" ] && continue
    echo "$line" | sed "s#^\.#$root#"
  done
}
if [ $# == 0 ]; then
    usage
    exit
fi

pars="-Hn"
root="."
file=""
depth=99
postproc=""
exclude=""
quiet=0
binary=0
grep_cmd="\grep"
ss=""
verbose=0
taction=0
topic=""
if [ ! -t 1 ]; then
    quiet=1
fi
while getopts habqicpr:n:f:e:s:gC:vwt:T:lLR: flag
do
    case $flag in
        t)
            topic=$OPTARG
            taction=1 # append
            ;;
        T)
            topic=$OPTARG
            taction=2 # print
            ;;
        l)
            taction=3 # list
            ;;
        L)
            taction=5 # print last used topic
            ;;
        R)
            topic=$OPTARG
            taction=4 # append
            ;;
        a)
            ack_grep=`which ack-grep`
            if [ ! -z "$ack_grep" ]; then
                grep_cmd="ack-grep"
            fi
            ;;

        v)
            verbose=1
            ;;
        b)
            binary=1
            ;;
        q)
            quiet=1
            ;;
        w)
            grep_cmd="$grep_cmd -w"
            ;;
        C)
            grep_cmd="$grep_cmd -$OPTARG"
            ;;
        e)
            exclude=$OPTARG
            ;;
        s)
            ss=$OPTARG
            pars="-l"
            postproc="xargs -I@ sed -i -e 's#$string#$ss#g' @"
            binary=0
            ;;
        i)
            pars+="i"
            ;;
        p)
            pars="-l"
            ;;
        c)
            # just count occurences, filter out files with not matching the string and revert sort the list
            pars="-Hnc"
            postproc="\grep -v \":0\"| sort -t \":\" -nr -k 2"
            ;;
        f)
            if [ "$file" == "" ]; then
                file="-name $OPTARG"
            else
                file+=" -or -name $OPTARG"
            fi
            ;;
        r)
            root=$OPTARG
            ;;
        n)
            depth=$OPTARG
            ;;
        h)
            usage
            exit
            ;;
        ?)
            usage
            exit
            ;;
    esac
done
shift $(( OPTIND - 1 ))  # shift to the last flag or argument

string=$1

bin_filter="| do-pipe-wrapped-text | xargs file | grep text | cut -d: -f1"
if [ $binary -eq 1 ]; then
    bin_filter=""
fi

#sav_filter="| grep -v \".sav$\""
sav_filter=""
verbose_cmd=""
if [ $verbose -eq 1 ]; then
	verbose_cmd="echo @;"
fi
if [ "$exclude" == "" ]; then
    cmd="find \"$root\" -maxdepth \"$depth\" \( -type d -name .svn -prune -o -type d -name .git -prune \) -o -type f $file $bin_filter $sav_filter | xargs -I@ sh -c \"$verbose_cmd $grep_cmd --color \\\"$pars\\\" \\\"$string\\\" \\\"@\\\"\""
else
    cmd="find \"$root\" -maxdepth \"$depth\" \( -type d -name .svn -prune -o -type d -name .git -prune \) -o -type f $file $bin_filter $sav_filter | xargs -I@ sh -c \"$grep_cmd --color \\\"$pars\\\" \\\"$string\\\" \\\"@\\\"| \grep -v \\\"$exclude\\\"|\grep --color \\\"$string\\\"\""
fi
if [ ! "$postproc" == "" ]; then
    cmd+="|$postproc"
fi
cmd+=" 2>/dev/null"

if [ $taction -gt 0 ]; then
    [ ! -d '${HOME}/.do-find-string' ] && mkdir -p "${HOME}/.do-find-string"
    #TODO: remove special characters from $string
    [ $taction -eq 5 ] && topic="-" && taction=2
    [ "$topic" == "-" ] && topic=$(ls -1t ~/.do-find-string/ | grep "\.txt$" | head -1 | sed 's#\.txt##') 
    [ $taction -eq 3 ] && ls -1 "${HOME}/.do-find-string/" | grep "\.txt$" | sed 's#\.txt##' && exit
    topic_file=$(echo "${HOME}/.do-find-string/${topic}.txt")
    [ $taction -eq 4 ] && cp "${topic_file}" "${topic_file}.bak" && rm -f "${topic_file}" && echo "Reset: ${topic_file} Backup: ${topic_file}.bak" && exit
    [ ! -f "${topic_file}" ] && echo "# do-find-string: topic=$topic" > "${topic_file}"
    [ $taction -eq 2 ] && print_topic "${topic}" && exit
    echo "# PWD=$PWD" >> "${topic_file}"
    #cmd+=" | sed \"s#^\\.#\$PWD#\""
    echo "# $cmd" >> "${topic_file}"
    [ $quiet -eq 0 ] && echo "> $cmd"
    eval $cmd | tee -a $topic_file  | \grep --color "^\|$string"
else
    [ $quiet -eq 0 ] && echo "> $cmd"
    eval $cmd 
fi
